<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo使用记录</title>
    <url>/2021/10/08/Hexo/</url>
    <content><![CDATA[<p>记录Hexo主题的一些命令</p>
<span id="more"></span>

<h3 id="Hexo常用命令"><a href="#Hexo常用命令" class="headerlink" title="Hexo常用命令"></a>Hexo常用命令</h3><p><img src="https://nanamyblog.oss-cn-beijing.aliyuncs.com/2021/10/9/hexo.svg" alt="Hexo"></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>简写</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>npm install hexo -g</td>
<td></td>
<td>安装hexo</td>
</tr>
<tr>
<td>npm update hexo -g</td>
<td></td>
<td>更新hexo</td>
</tr>
<tr>
<td>hexo init</td>
<td></td>
<td>初始化</td>
</tr>
<tr>
<td>npm install hexo-xxxx –save</td>
<td></td>
<td>安装插件</td>
</tr>
<tr>
<td>npm uninstall hexo-xxx –save</td>
<td></td>
<td>卸载插件</td>
</tr>
<tr>
<td>hexo n “文章名”</td>
<td></td>
<td>新建文章(日常在source/_drafts目录下创建文件是草稿，source/_posts目录下创建文件是发布的文章)</td>
</tr>
<tr>
<td>hexo clean</td>
<td></td>
<td>清除缓存</td>
</tr>
<tr>
<td>hexo generate</td>
<td>hexo g</td>
<td>生成静态文件(public文件夹内容生成)</td>
</tr>
<tr>
<td>hexo deploy</td>
<td>hexo d</td>
<td>部署</td>
</tr>
<tr>
<td>hexo d -g</td>
<td></td>
<td>生成静态文件并部署</td>
</tr>
<tr>
<td>hexo server</td>
<td>hexo s</td>
<td>预览,启动服务器</td>
</tr>
<tr>
<td>hexo s -p 端口号</td>
<td></td>
<td>自定义端口号</td>
</tr>
<tr>
<td>hexo s -i IP地址</td>
<td></td>
<td>自定义IP</td>
</tr>
<tr>
<td>hexo s -s</td>
<td></td>
<td>使用静态文件启动</td>
</tr>
</tbody></table>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://hexo.io/docs/one-command-deployment.html">Hexo官网</a></p>
<p><a href="https://zhwangart.com/2018/11/30/Ocean/">Ocean文档</a></p>
<p><a href="https://zhwangart.com/2019/07/02/Ocean-Issues/">Ocean Issues</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title>Dart</title>
    <url>/2021/10/10/Dart/</url>
    <content><![CDATA[<p>Dart基础语法笔记</p>
<span id="more"></span>

<h3 id="Dart介绍："><a href="#Dart介绍：" class="headerlink" title="Dart介绍："></a>Dart介绍：</h3><p>Dart是由谷歌开发的计算机编程语言,它可以被用于web、服务器、移动应用 和物联网等领域的开发。</p>
<p>Dart诞生于2011年，号称要取代JavaScript。但是过去的几年中一直不温不火。直到Flutter的出现现在被人们重新重视。</p>
<p>要学Flutter的话我们必须首先得会Dart。</p>
<h3 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;Hello world&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Dart变量，常量，命名规则"><a href="#Dart变量，常量，命名规则" class="headerlink" title="Dart变量，常量，命名规则"></a>Dart变量，常量，命名规则</h3><h4 id="Dart变量"><a href="#Dart变量" class="headerlink" title="Dart变量"></a>Dart变量</h4><p>dart是一个强大的脚本类语言，可以不预先定义变量类型 ，自动会类型推倒。</p>
<p>dart中定义变量可以通过var关键字可以通过类型来申明变量，如：</p>
   <figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">&#x27;this is var&#x27;</span>;</span><br><span class="line"><span class="built_in">String</span> str=<span class="string">&#x27;this is String&#x27;</span>;</span><br><span class="line"><span class="built_in">int</span> str=<span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<h4 id="Dart常量"><a href="#Dart常量" class="headerlink" title="Dart常量"></a>Dart常量</h4><blockquote>
<p>final 和 const修饰符 </p>
</blockquote>
<p>const值不变 一开始就得赋值。</p>
<p>final 可以开始不赋值 只能赋一次 ; 而final不仅有const的编译时常量的特性，最重要的它是运行时常量，并且final是惰性初始化，即在运行时第一次使用前才初始化。</p>
<h4 id="Dart命名规则"><a href="#Dart命名规则" class="headerlink" title="Dart命名规则"></a>Dart命名规则</h4><ul>
<li>变量名称必须由数字、字母、下划线和美元符($)组成。</li>
<li>标识符开头不能是数字。</li>
<li>标识符不能是保留字和关键字。</li>
<li>变量的名字是区分大小写的。</li>
</ul>
<h3 id="Dart数据类型"><a href="#Dart数据类型" class="headerlink" title="Dart数据类型"></a>Dart数据类型</h3><p>​    Dart支持的数据类型有：</p>
<ul>
<li>int</li>
<li>double</li>
<li>String</li>
<li>bool</li>
<li>List</li>
<li>Map</li>
</ul>
<h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str1=<span class="string">&#x27;this is str1&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> str2=<span class="string">&quot;this is str2&quot;</span>;</span><br><span class="line"><span class="built_in">String</span> str1=<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">  this is str1</span></span><br><span class="line"><span class="string">  this is str1</span></span><br><span class="line"><span class="string">  this is str1</span></span><br><span class="line"><span class="string">  &#x27;&#x27;&#x27;</span>;</span><br><span class="line"><span class="built_in">String</span> str1=<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    this is str1</span></span><br><span class="line"><span class="string">    this is str1</span></span><br><span class="line"><span class="string">    this is str1</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>;</span><br><span class="line"><span class="comment">//字符串拼接</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;<span class="subst">$str1</span> <span class="subst">$str2</span>&quot;</span>);</span><br><span class="line"><span class="built_in">print</span>(str1 + str2);</span><br></pre></td></tr></table></figure>

<h4 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、int   必须是整型</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">int</span> a=<span class="number">123</span>;</span><br><span class="line"></span><br><span class="line">  a=<span class="number">45</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(a);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、double  既可以是整型 也可是浮点型</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">double</span> b=<span class="number">23.5</span>;</span><br><span class="line"></span><br><span class="line">  b=<span class="number">24</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(b);</span><br></pre></td></tr></table></figure>

<h4 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a>List类型</h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、第一种定义List的方式，不指定类型可以装任意类型。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> l1=[<span class="string">&quot;张三&quot;</span>,<span class="number">20</span>,<span class="keyword">true</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(l1);  <span class="comment">//[张三, 20, true]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(l1.length);  <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(l1[<span class="number">0</span>]); <span class="comment">//张三</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(l1[<span class="number">1</span>]); <span class="comment">//20</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//2、第二种定义List的方式 指定类型</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> l2 = &lt;<span class="built_in">String</span>&gt;[<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(l2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> l3 = &lt;<span class="built_in">int</span>&gt;[<span class="number">12</span>, <span class="number">30</span>];</span><br><span class="line">  <span class="built_in">print</span>(l3);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//3、第三种定义List的方式  增加数据 ,通过[]创建的集合它的容量可以变化</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> l4 = [];</span><br><span class="line">  <span class="built_in">print</span>(l4);</span><br><span class="line">  <span class="built_in">print</span>(l4.length);</span><br><span class="line"></span><br><span class="line">  l4.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">  l4.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">  l4.add(<span class="number">20</span>);</span><br><span class="line">  <span class="built_in">print</span>(l4);</span><br><span class="line">  <span class="built_in">print</span>(l4.length);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> l5 = [<span class="string">&quot;张三&quot;</span>, <span class="number">20</span>, <span class="keyword">true</span>];</span><br><span class="line">  l5.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">  l5.add(<span class="string">&quot;zhaosi&quot;</span>);</span><br><span class="line">  <span class="built_in">print</span>(l5);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//4、第四种定义List的方式</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> l6 = <span class="built_in">List</span>.filled(<span class="number">2</span>, <span class="string">&quot;1&quot;</span>); <span class="comment">//创建一个 固定 长度为2的集合,填充“1”</span></span><br><span class="line">  <span class="built_in">print</span>(l6);<span class="comment">//[1,1]</span></span><br><span class="line">  <span class="built_in">print</span>(l6[<span class="number">0</span>]);<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">  l6[<span class="number">0</span>]=<span class="string">&quot;张三&quot;</span>;   <span class="comment">//修改集合的内容</span></span><br><span class="line">  l6[<span class="number">1</span>]=<span class="string">&quot;李四&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(l6);  <span class="comment">//[张三, 李四]</span></span><br><span class="line"></span><br><span class="line">  l6.add(<span class="string">&quot;王五&quot;</span>);  <span class="comment">//错误写法，不能修改长度</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//通过List.filled创建的集合长度是固定</span></span><br><span class="line">  <span class="keyword">var</span> l6=<span class="built_in">List</span>.filled(<span class="number">2</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="built_in">print</span>(l6.length);</span><br><span class="line">  l6.length=<span class="number">0</span>;  <span class="comment">//修改集合的长度   报错</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> l7 = &lt;<span class="built_in">String</span>&gt;[<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>];</span><br><span class="line">  <span class="built_in">print</span>(l7.length); <span class="comment">//2</span></span><br><span class="line">  l7.length = <span class="number">0</span>; <span class="comment">//可以改变的</span></span><br><span class="line">  <span class="built_in">print</span>(l7); <span class="comment">//[]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> l8 = <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;.filled(<span class="number">2</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  l8[<span class="number">0</span>] = <span class="string">&quot;string&quot;</span>;</span><br><span class="line">  l8[<span class="number">0</span>]=<span class="number">222</span>;</span><br><span class="line">  <span class="built_in">print</span>(l8);</span><br></pre></td></tr></table></figure>

<h4 id="Map类型"><a href="#Map类型" class="headerlink" title="Map类型"></a>Map类型</h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一种定义 Maps的方式</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="string">&quot;work&quot;</span>: [<span class="string">&quot;程序员&quot;</span>, <span class="string">&quot;送外卖&quot;</span>]</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(person);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(person[<span class="string">&quot;name&quot;</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(person[<span class="string">&quot;age&quot;</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(person[<span class="string">&quot;work&quot;</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//第二种定义 Maps的方式</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">  p[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">  p[<span class="string">&quot;age&quot;</span>] = <span class="number">22</span>;</span><br><span class="line">  p[<span class="string">&quot;work&quot;</span>] = [<span class="string">&quot;程序员&quot;</span>, <span class="string">&quot;送外卖&quot;</span>];</span><br><span class="line">  <span class="built_in">print</span>(p);</span><br><span class="line">  <span class="built_in">print</span>(p[<span class="string">&quot;age&quot;</span>]);</span><br></pre></td></tr></table></figure>

<h4 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(str <span class="keyword">is</span> <span class="built_in">String</span>)&#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;是string类型&#x27;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(str <span class="keyword">is</span> <span class="built_in">int</span>)&#123;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;int&#x27;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;其他类型&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Dart类的继承"><a href="#Dart类的继承" class="headerlink" title="Dart类的继承"></a>Dart类的继承</h3><p>Dart中的类的继承：  </p>
<ul>
<li>子类使用extends关键词来继承父类</li>
<li>子类会继承父类里面可见的属性和方法 但是不会继承构造函数 </li>
<li>子类能复写父类的方法 getter和setter</li>
</ul>
<h4 id="简单继承"><a href="#简单继承" class="headerlink" title="简单继承"></a>简单继承</h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name=<span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line">  <span class="built_in">num</span> age=<span class="number">20</span>; </span><br><span class="line">  <span class="keyword">void</span> printInfo() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>---<span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span>&quot;</span>);  </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Web</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()&#123;   </span><br><span class="line"></span><br><span class="line">  Web w=<span class="keyword">new</span> Web();</span><br><span class="line">  <span class="built_in">print</span>(w.name);</span><br><span class="line">  w.printInfo();</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Super关键词"><a href="#Super关键词" class="headerlink" title="Super关键词"></a>Super关键词</h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">late</span> <span class="built_in">String</span> name;</span><br><span class="line">  <span class="keyword">late</span> <span class="built_in">num</span> age; </span><br><span class="line">  Person(<span class="keyword">this</span>.name,<span class="keyword">this</span>.age);</span><br><span class="line">  <span class="keyword">void</span> printInfo() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>---<span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span>&quot;</span>);  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Web</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="comment">//: 之后的代码块会在构造函数的具体代码内容执行之前执行</span></span><br><span class="line">  Web(<span class="built_in">String</span> name, <span class="built_in">num</span> age) : <span class="keyword">super</span>(name, age)&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()&#123; </span><br><span class="line">  Web w=<span class="keyword">new</span> Web(<span class="string">&#x27;张三&#x27;</span>, <span class="number">12</span>);</span><br><span class="line">  w.printInfo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//==========================================</span></span><br><span class="line"><span class="comment">//继承并构建自己的属性和方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Web</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="keyword">late</span> <span class="built_in">String</span> sex;</span><br><span class="line">  Web(<span class="built_in">String</span> name, <span class="built_in">num</span> age,<span class="built_in">String</span> sex) : <span class="keyword">super</span>(name, age)&#123;</span><br><span class="line">    <span class="keyword">this</span>.sex=sex;</span><br><span class="line">  &#125;</span><br><span class="line">  run()&#123;</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>---<span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span>--<span class="subst">$&#123;<span class="keyword">this</span>.sex&#125;</span>&quot;</span>);  </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()&#123; </span><br><span class="line"></span><br><span class="line">  Web w=<span class="keyword">new</span> Web(<span class="string">&#x27;张三&#x27;</span>, <span class="number">12</span>,<span class="string">&quot;男&quot;</span>);</span><br><span class="line"></span><br><span class="line">  w.printInfo();</span><br><span class="line"></span><br><span class="line">  w.run();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">num</span> age;</span><br><span class="line">  Person(<span class="keyword">this</span>.name, <span class="keyword">this</span>.age);</span><br><span class="line">  <span class="keyword">void</span> printInfo() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>---<span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span>&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> work() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>在工作...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Web</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  Web(<span class="built_in">String</span> name, <span class="built_in">num</span> age) : <span class="keyword">super</span>(name, age);</span><br><span class="line"></span><br><span class="line">  run() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;run&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//覆写父类的方法</span></span><br><span class="line">  <span class="meta">@override</span> </span><br><span class="line">  <span class="keyword">void</span> printInfo() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;姓名：<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>---年龄：<span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span>&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> work() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>的工作是写代码&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  Web w = <span class="keyword">new</span> Web(<span class="string">&#x27;李四&#x27;</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">  w.printInfo();</span><br><span class="line"></span><br><span class="line">  w.work();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Dart-抽象类，多态，接口"><a href="#Dart-抽象类，多态，接口" class="headerlink" title="Dart 抽象类，多态，接口"></a>Dart 抽象类，多态，接口</h3><p>Dart中抽象类: Dart抽象类主要用于定义标准，子类可以继承抽象类，也可以实现抽象类接口。</p>
<ul>
<li><p>抽象类通过abstract 关键字来定义</p>
</li>
<li><p>Dart中的抽象方法不能用abstract声明，Dart中没有方法体的方法我们称为抽象方法。</p>
</li>
<li><p>如果子类（非抽象类）继承抽象类必须得实现里面的抽象方法</p>
</li>
<li><p>如果把抽象类当做接口实现的话必须得实现抽象类里面定义的所有属性和方法。</p>
</li>
<li><p>抽象类不能被实例化，只有继承它的子类（非抽象类）可以</p>
</li>
</ul>
<p>extends抽象类 和 implements的区别：</p>
<ul>
<li><p>如果要复用抽象类里面的方法，并且要用抽象方法约束自类的话我们就用extends继承抽象类</p>
</li>
<li><p>如果只是把抽象类当做标准的话我们就用implements实现抽象类</p>
</li>
</ul>
<h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">  eat();   <span class="comment">//抽象方法</span></span><br><span class="line">  run();  <span class="comment">//抽象方法  </span></span><br><span class="line">  printInfo()&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;我是一个抽象类里面的普通方法&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  eat() &#123;</span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&#x27;小狗在吃骨头&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  run() &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement run</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;小狗在跑&#x27;</span>);</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  eat() &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement eat</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;小猫在吃老鼠&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  run() &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement run</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;小猫在跑&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()&#123;</span><br><span class="line">  Dog d=<span class="keyword">new</span> Dog();</span><br><span class="line">  d.eat();</span><br><span class="line">  d.printInfo();</span><br><span class="line"></span><br><span class="line">   Cat c=<span class="keyword">new</span> Cat();</span><br><span class="line">  c.eat();</span><br><span class="line">  c.printInfo();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Animal a=new Animal();   //抽象类没法直接被实例化</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>Datr中的多态：</p>
<ul>
<li><p>允许将子类类型的指针赋值给父类类型的指针, 同一个函数调用会有不同的执行效果 。</p>
</li>
<li><p>子类的实例赋值给父类的引用。</p>
</li>
</ul>
<p><strong>多态就是父类定义一个方法不去实现，让继承他的子类去实现，每个子类有不同的表现。</strong></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">  eat();   <span class="comment">//抽象方法 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  eat() &#123;</span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&#x27;小狗在吃骨头&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  run()&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;run&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  eat() &#123;   </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;小猫在吃老鼠&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  run()&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;run&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()&#123;</span><br><span class="line"></span><br><span class="line">  Animal d=<span class="keyword">new</span> Dog();</span><br><span class="line">  d.eat();</span><br><span class="line"></span><br><span class="line">  Animal c=<span class="keyword">new</span> Cat();</span><br><span class="line">  c.eat();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>和Java一样，dart也有接口，但是和Java还是有区别的。</p>
<p>首先，dart的接口没有interface关键字定义接口，而是普通类或抽象类都可以作为接口被实现。</p>
<p>同样使用implements关键字进行实现。</p>
<p>但是dart的接口有点奇怪，如果实现的类是普通类，会将普通类和抽象中的属性的方法全部需要覆写一遍。</p>
<p>而因为抽象类可以定义抽象方法，普通类不可以，所以一般如果要实现像Java接口那样的方式，一般会使用抽象类。</p>
<p>建议使用抽象类定义接口。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Db</span> </span>&#123;</span><br><span class="line">  <span class="comment">//当做接口   接口：就是约定 、规范</span></span><br><span class="line">  <span class="keyword">late</span> <span class="built_in">String</span> uri; <span class="comment">//数据库的链接地址</span></span><br><span class="line">  add(<span class="built_in">String</span> data);</span><br><span class="line">  save();</span><br><span class="line">  delete();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mysql</span> <span class="keyword">implements</span> <span class="title">Db</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> uri;</span><br><span class="line"></span><br><span class="line">  Mysql(<span class="keyword">this</span>.uri);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  add(data) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;这是mysql的add方法&#x27;</span> + data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  delete() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  save() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  remove() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MsSql</span> <span class="keyword">implements</span> <span class="title">Db</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">late</span> <span class="built_in">String</span> uri;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  add(<span class="built_in">String</span> data) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;这是mssql的add方法&#x27;</span> + data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  delete() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  save() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  Mysql mysql = <span class="keyword">new</span> Mysql(<span class="string">&#x27;xxxxxx&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  mysql.add(<span class="string">&#x27;1243214&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="接口文件分离"><a href="#接口文件分离" class="headerlink" title="接口文件分离"></a>接口文件分离</h4><ol>
<li>将Db，Mysql，Mssql分别写入各自的文件中并且放入lib文件夹下</li>
<li>在需要的时候引入类文件</li>
</ol>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;lib/MsSql.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="comment">// Mysql mysql=new Mysql(&#x27;xxxxxx&#x27;);</span></span><br><span class="line">  <span class="comment">// mysql.add(&#x27;1243214&#x27;);</span></span><br><span class="line"></span><br><span class="line">  MsSql mssql = <span class="keyword">new</span> MsSql();</span><br><span class="line">  mssql.uri = <span class="string">&#x27;127.0.0.1&#x27;</span>;</span><br><span class="line">  mssql.add(<span class="string">&#x27;增加的数据&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现多个接口"><a href="#实现多个接口" class="headerlink" title="实现多个接口"></a>实现多个接口</h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">late</span> <span class="built_in">String</span> name;</span><br><span class="line">  printA();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">  printB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">A</span>, <span class="title">B</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">late</span> <span class="built_in">String</span> name;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  printA() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;printA&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  printB() &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement printB</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  C c = <span class="keyword">new</span> C();</span><br><span class="line">  c.printA();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Mixins混入"><a href="#Mixins混入" class="headerlink" title="Mixins混入"></a>Mixins混入</h3><p>mixins的中文意思是混入，就是混合多个类其他功能。</p>
<p>在Dart中可以使用mixins实现类似多继承的功能</p>
<p>因为mixins使用的条件，随着Dart版本一直在变，这里讲的是Dart2.x中使用mixins的条件：</p>
<ul>
<li><p>作为mixins的类只能直接继承自Object，不能继承其他类，不能是mixins之后的类。</p>
</li>
<li><p>作为mixins的类不能有构造函数</p>
</li>
<li><p>mixins绝不是继承，也不是接口，而是一种全新的特性</p>
</li>
<li><p>mixins之后的类的示例对象是所有参与mixins类的子类</p>
</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> info = <span class="string">&quot;this is A&quot;</span>;</span><br><span class="line">  <span class="keyword">void</span> printA() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> printB() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="title">with</span> <span class="title">A</span>, <span class="title">B</span> </span>&#123;&#125;<span class="comment">//with关键词实现mixins</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> c = <span class="keyword">new</span> C();</span><br><span class="line">  c.printA();</span><br><span class="line">  c.printB();</span><br><span class="line">  <span class="built_in">print</span>(c.info);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">num</span> age;</span><br><span class="line">  Person(<span class="keyword">this</span>.name, <span class="keyword">this</span>.age);</span><br><span class="line">  printInfo() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>----<span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span>&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> run() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Person Run&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> info = <span class="string">&quot;this is A&quot;</span>;</span><br><span class="line">  <span class="keyword">void</span> printA() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> run() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;A Run&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> printB() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> run() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;B Run&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">Person</span> <span class="title">with</span> <span class="title">B</span>, <span class="title">A</span> </span>&#123;</span><br><span class="line">  C(<span class="built_in">String</span> name, <span class="built_in">num</span> age) : <span class="keyword">super</span>(name, age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> c = <span class="keyword">new</span> C(<span class="string">&#x27;张三&#x27;</span>, <span class="number">20</span>);</span><br><span class="line">  c.printInfo();</span><br><span class="line">  c.printB();</span><br><span class="line">  <span class="built_in">print</span>(c.info);</span><br><span class="line"></span><br><span class="line">  c.run();<span class="comment">//混合类还有继承类如果有相同的方法后面的方法会替换前面的方法，在这里是A.run</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Dart泛型"><a href="#Dart泛型" class="headerlink" title="Dart泛型"></a>Dart泛型</h3><h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">T getData&lt;T&gt;(T value) &#123;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(getData(<span class="string">&#x27;xxx&#x27;</span>));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(getData&lt;<span class="built_in">int</span>&gt;(<span class="number">12</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">List</span> list = &lt;T&gt;[];</span><br><span class="line">  <span class="keyword">void</span> add(T value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.list.add(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">List</span> getList() &#123;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  MyList l1 = <span class="keyword">new</span> MyList();</span><br><span class="line">  l1.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">  l1.add(<span class="number">12</span>);</span><br><span class="line">  l1.add(<span class="keyword">true</span>);</span><br><span class="line">  <span class="built_in">print</span>(l1.getList());</span><br><span class="line"></span><br><span class="line">  MyList l2 = <span class="keyword">new</span> MyList&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">  l2.add(<span class="string">&quot;张三1&quot;</span>);</span><br><span class="line">  <span class="comment">// l2.add(11);  //错误的写法</span></span><br><span class="line">  <span class="built_in">print</span>(l2.getList());</span><br><span class="line"></span><br><span class="line">  MyList l3 = <span class="keyword">new</span> MyList&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">  l3.add(<span class="number">11</span>);</span><br><span class="line">  l3.add(<span class="number">12</span>);</span><br><span class="line">  <span class="comment">//l3.add(&quot;aaaa&quot;);//报错</span></span><br><span class="line">  <span class="built_in">print</span>(l3.getList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><p>Dart中的泛型接口在实现时实现类也要是泛型类。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Cache</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  getByKey(<span class="built_in">String</span> key);</span><br><span class="line">  <span class="keyword">void</span> setByKey(<span class="built_in">String</span> key, T value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlieCache</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Cache</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  getByKey(<span class="built_in">String</span> key) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> setByKey(<span class="built_in">String</span> key, T value) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我是文件缓存 把key=<span class="subst">$&#123;key&#125;</span>  value=<span class="subst">$&#123;value&#125;</span>的数据写入到了文件中&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemoryCache</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Cache</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  getByKey(<span class="built_in">String</span> key) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> setByKey(<span class="built_in">String</span> key, T value) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我是内存缓存 把key=<span class="subst">$&#123;key&#125;</span>  value=<span class="subst">$&#123;value&#125;</span> -写入到了内存中&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">// MemoryCache m=new MemoryCache&lt;String&gt;();</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  m.setByKey(&#x27;index&#x27;, &#x27;首页数据&#x27;);</span></span><br><span class="line"></span><br><span class="line">  Cache m = <span class="keyword">new</span> MemoryCache&lt;<span class="built_in">Map</span>&gt;();</span><br><span class="line"></span><br><span class="line">  m.setByKey(<span class="string">&#x27;index&#x27;</span>, &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;张三&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">20</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Dart库"><a href="#Dart库" class="headerlink" title="Dart库"></a>Dart库</h3><p>前面介绍Dart基础知识的时候基本上都是在一个文件里面编写Dart代码的，但实际开发中不可能这么写，模块化很重要，所以这就需要使用到库的概念。</p>
<p>在Dart中，库的使用时通过import关键字引入的。</p>
<p>library指令可以创建一个库，每个Dart文件都是一个库，即使没有使用library指令来指定。</p>
<p>Dart中的库主要有三种：</p>
<p>​    1、我们自定义的库     </p>
<p>​          import ‘lib/xxx.dart’;</p>
<p>​    2、系统内置库       </p>
<p>​          import ‘dart:math’;    </p>
<p>​          import ‘dart:io’; </p>
<p>​          import ‘dart:convert’;</p>
<p>​    3、Pub包管理系统中的库  </p>
<p>​        <a href="https://pub.dev/packages">https://pub.dev/packages</a></p>
<p>​        <a href="https://pub.flutter-io.cn/packages">https://pub.flutter-io.cn/packages</a></p>
<p>​        <a href="https://pub.dartlang.org/flutter/">https://pub.dartlang.org/flutter/</a></p>
<p>​        1、需要在自己想项目根目录新建一个pubspec.yaml</p>
<p>​        2、在pubspec.yaml文件 然后配置名称 、描述、环境、依赖等信息，如：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">xxx</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">A</span> <span class="string">new</span> <span class="string">flutter</span> <span class="string">module</span> <span class="string">project.</span></span><br><span class="line"><span class="attr">environment:</span></span><br><span class="line">  <span class="attr">sdk:</span> <span class="string">&#x27;&gt;=2.10.0 &lt;3.0.0&#x27;</span></span><br><span class="line"><span class="comment">#dependencies:</span></span><br><span class="line">  <span class="comment">#http: ^0.12.0+2</span></span><br><span class="line">  <span class="comment">#date_format: ^1.0.6</span></span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/mengks1987/article/details/109500041">参考资料</a></p>
<p>​        3、然后运行 pub get 获取包下载到本地  </p>
<ul>
<li>或者使用 <code>dart pub add http</code> <code>flutter pub add http</code>添加依赖</li>
</ul>
<p>​        4、项目中引入库 import ‘package:http/http.dart’ as http; 看文档使用</p>
<h4 id="库冲突解决"><a href="#库冲突解决" class="headerlink" title="库冲突解决"></a>库冲突解决</h4><p>当引入两个库中有相同名称标识符的时候（如同时存在同名的类），如果是java通常我们通过写上完整的包名路径来指定使用的具体标识符，甚至不用import都可以，但是Dart里面是必须import的。当冲突的时候，可以使用as关键字来指定库的前缀。如下例子所示：</p>
<pre><code><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:lib1/lib1.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:lib2/lib2.dart&#x27;</span> <span class="keyword">as</span> lib2;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Element</span> element1 = <span class="keyword">new</span> <span class="built_in">Element</span>();           <span class="comment">// Uses Element from lib1.</span></span><br><span class="line"></span><br><span class="line">lib2.<span class="built_in">Element</span> element2 = <span class="keyword">new</span> lib2.<span class="built_in">Element</span>(); <span class="comment">// Uses Element from lib2.</span></span><br><span class="line">​    ```</span><br><span class="line"></span><br><span class="line">#### 库部分导入</span><br><span class="line"></span><br><span class="line">部分导入</span><br><span class="line"></span><br><span class="line">  如果只需要导入库的一部分，有两种模式：</span><br><span class="line"></span><br><span class="line">​     模式一：只导入需要的部分，使用<span class="keyword">show</span>关键字，如下例子所示：</span><br><span class="line"></span><br><span class="line">​     `<span class="keyword">import</span> <span class="string">&#x27;package:lib1/lib1.dart&#x27;</span> <span class="keyword">show</span> foo;`</span><br><span class="line"></span><br><span class="line">​     模式二：隐藏不需要的部分，使用<span class="keyword">hide</span>关键字，如下例子所示：</span><br><span class="line"></span><br><span class="line">​     ` <span class="keyword">import</span> <span class="string">&#x27;package:lib2/lib2.dart&#x27;</span> <span class="keyword">hide</span> foo; ` </span><br><span class="line"></span><br><span class="line">#### 延迟加载</span><br><span class="line"></span><br><span class="line">```dart</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">延迟加载</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    也称为懒加载，可以在需要的时候再进行加载。</span></span><br><span class="line"><span class="comment">    懒加载的最大好处是可以减少APP的启动时间。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    懒加载使用deferred as关键字来指定，如下例子所示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    import &#x27;package:deferred/hello.dart&#x27; deferred as hello;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    当需要使用的时候，需要使用loadLibrary()方法来加载：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    greet() async &#123;</span></span><br><span class="line"><span class="comment">      await hello.loadLibrary();</span></span><br><span class="line"><span class="comment">      hello.printGreeting();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</code></pre>
<h4 id="分库，export"><a href="#分库，export" class="headerlink" title="分库，export"></a>分库，export</h4><p>dart中，通过使用part、part of、library来实现拆分库，这样，就可以将一个庞大的库拆分成各种小库，只要引用主库即可，用法如下：</p>
<p>假设有三个文件，两个子库calculator和logger，一个主库util  </p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//calculator.dart代码：</span></span><br><span class="line"><span class="comment">//和主库建立连接</span></span><br><span class="line"><span class="keyword">part</span> of util;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> add(<span class="built_in">int</span> i, <span class="built_in">int</span> j) &#123;</span><br><span class="line">  <span class="keyword">return</span> i + j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> sub(<span class="built_in">int</span> i, <span class="built_in">int</span> j) &#123;</span><br><span class="line">  <span class="keyword">return</span> i - j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> random(<span class="built_in">int</span> no) &#123;</span><br><span class="line">  <span class="keyword">return</span> Random().nextInt(no);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//========================================</span></span><br><span class="line"><span class="comment">//logger.dart代码：</span></span><br><span class="line"><span class="comment">//和主库建立连接</span></span><br><span class="line"><span class="keyword">part</span> of util;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> _app_name;</span><br><span class="line">  Logger(<span class="keyword">this</span>._app_name);</span><br><span class="line">  <span class="keyword">void</span> error(error) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;<span class="subst">$&#123;_app_name&#125;</span>Error:<span class="subst">$&#123;error&#125;</span>&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> warn(msg) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;<span class="subst">$&#123;_app_name&#125;</span>Error:<span class="subst">$&#123;msg&#125;</span>&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> debug(msg) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;<span class="subst">$&#123;_app_name&#125;</span>Error:<span class="subst">$&#123;msg&#125;</span>&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//=========================================</span></span><br><span class="line"><span class="comment">//主库util.dart代码：</span></span><br><span class="line"><span class="comment">//给库命名</span></span><br><span class="line"><span class="keyword">library</span> util;</span><br><span class="line"></span><br><span class="line"><span class="comment">//导入math，子库用到</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:math&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//和子库建立联系</span></span><br><span class="line"><span class="keyword">part</span> <span class="string">&#x27;logger.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">part</span> <span class="string">&#x27;calculator.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//===========================================</span></span><br><span class="line"><span class="comment">//使用：</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./util.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">//使用logger库定义的类</span></span><br><span class="line">  Logger logger = Logger(<span class="string">&#x27;Demo&#x27;</span>);</span><br><span class="line">  logger.debug(<span class="string">&#x27;这是debug信息&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//使用calculator库定义的方法</span></span><br><span class="line">  <span class="built_in">print</span>(add(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>export的作用相当于在A库将多个库导入，且所有引用A库的文件都将引用所有export导入的文件，相当于将库收集在一起，无需在项目中一个一个导入</strong></p>
<h3 id="Dart异步"><a href="#Dart异步" class="headerlink" title="Dart异步"></a>Dart异步</h3><blockquote>
<p> async和await关键词</p>
</blockquote>
<p>这两个关键字的使用只需要记住两点：</p>
<ul>
<li><p>只有async方法才能使用await关键字调用方法</p>
</li>
<li><p>如果调用别的async方法可以使用await关键字等待完成</p>
</li>
</ul>
<p>async是让方法变成异步。</p>
<p>await是等待异步方法执行完成。（如果不需要立刻获得异步方法的值，则可以不用）</p>
<h3 id="Dart2-13之后新特性"><a href="#Dart2-13之后新特性" class="headerlink" title="Dart2.13之后新特性"></a>Dart2.13之后新特性</h3><h4 id="Null-safety，可空类型，非空断言"><a href="#Null-safety，可空类型，非空断言" class="headerlink" title="Null safety，可空类型，非空断言"></a>Null safety，可空类型，非空断言</h4><p>Null safety翻译成中文的意思是空安全。</p>
<p>null safety 可以帮助开发者避免一些日常开发中很难被发现的错误，并且额外的好处是可以改善性能。</p>
<p>Flutter2.2.0（2021年5月19日发布） 之后的版本都要求使用null safety。</p>
<blockquote>
<p>? 可空类型，加在类型后，如<code>int? a = null</code></p>
</blockquote>
<blockquote>
<p>! 类型断言，<code>print(str!.length);</code> 如果str不等于null 会打印str的长度，如果等于null会抛出异常，可以catch这个异常。</p>
</blockquote>
<h4 id="late"><a href="#late" class="headerlink" title="late"></a>late</h4><blockquote>
<p>late 关键字主要用于延迟初始化。</p>
</blockquote>
<h4 id="required"><a href="#required" class="headerlink" title="required"></a>required</h4><p>required关键词:</p>
<ul>
<li><p>最开始 @required 是注解</p>
</li>
<li><p>现在它已经作为内置修饰符。</p>
</li>
<li><p>主要用于允许根据需要标记任何<code>命名参数</code>(带{}，调用时要指定名)（函数或类），使得它们不为空。因为可选参数中必须有个 required 参数或者该参数有个默认值。</p>
</li>
<li><p><code>String printInfo(String username, &#123;required int age, required String sex&#125;) &#123;&#125;</code></p>
</li>
<li><pre><code class="dart">class Person &#123;
  String name;
  int age;
  Person(&#123;required this.name,required this.age&#125;);  //表示 name 和age 必须传入

  String getName() &#123;
    return &quot;$&#123;this.name&#125;---$&#123;this.age&#125;&quot;;
  &#125;
&#125;
void main(args) &#123;
   Person p=new Person(
     name: &quot;张三&quot;,
     age: 20
   );
   print(p.getName());
&#125;
</code></pre>
</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://dart.dev/">Dart官网</a></p>
<p><a href="dart.cn">中文官网</a></p>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title>每日英语单词</title>
    <url>/2021/10/11/%E8%8B%B1%E8%AF%AD/</url>
    <content><![CDATA[<p>每日单词记录</p>
<span id="more"></span>

<blockquote>
<p> 2021/10/11</p>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>rank</td>
<td><code>v</code>排名，把…分等级 <code>n</code>等级，级别<code>adj</code>繁茂的</td>
</tr>
<tr>
<td>bonus</td>
<td><code>n</code> 奖金，额外津贴</td>
</tr>
<tr>
<td>requirement</td>
<td><code>n</code> 要求，需求，必需品</td>
</tr>
<tr>
<td>infrared</td>
<td><code>adj</code> 红外线的<code>n</code> 红外线</td>
</tr>
<tr>
<td>contact</td>
<td><code>v</code> <code>n</code> 联系</td>
</tr>
<tr>
<td>oblige</td>
<td><code>v</code> 迫使，使感激，使…成为必要</td>
</tr>
<tr>
<td>reckon</td>
<td><code>vt</code> 估算，认为</td>
</tr>
<tr>
<td>deputy</td>
<td><code>n</code> 代表</td>
</tr>
<tr>
<td>interact</td>
<td><code>v</code> 交流，互动</td>
</tr>
<tr>
<td>concern</td>
<td><code>n</code> 关心 <code>v</code> 感兴趣</td>
</tr>
<tr>
<td>compile</td>
<td><code>v</code> 收集，汇编</td>
</tr>
<tr>
<td>foundation</td>
<td><code> n</code> 地基，基金会</td>
</tr>
<tr>
<td>forth</td>
<td><code>adv</code> 向前，离去</td>
</tr>
<tr>
<td>remark</td>
<td><code>n</code> <code>v</code> 评论，议论</td>
</tr>
<tr>
<td>prudent</td>
<td><code>adj</code> 谨慎的，精明的</td>
</tr>
<tr>
<td>specialist</td>
<td><code>n</code>专家<code>adj</code> 专家的</td>
</tr>
<tr>
<td>failure</td>
<td><code>n</code> 失败</td>
</tr>
<tr>
<td>medium</td>
<td><code>adj</code> 中等的<code>n</code> 手段，方法，媒介，材料</td>
</tr>
<tr>
<td>eminent</td>
<td><code>adj</code>杰出的</td>
</tr>
<tr>
<td>shallow</td>
<td><code>adj</code>浅的，肤浅的<code>v</code> 变浅，使变浅</td>
</tr>
</tbody></table>
<hr>
<blockquote>
<p>2021/10/12</p>
</blockquote>
<hr>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>intense</td>
<td><code>adj</code> 强烈的，激烈的，紧张的，认真的，热情的</td>
</tr>
<tr>
<td>offspring</td>
<td><code>n</code> 后代</td>
</tr>
<tr>
<td>expand</td>
<td><code>v</code> 扩大，扩张</td>
</tr>
<tr>
<td>pump</td>
<td><code>v</code>抽取，抽水 <code>n</code> 打气筒，水泵</td>
</tr>
<tr>
<td>upward</td>
<td><code>adj</code> <code>adv</code> 向上的、向上地</td>
</tr>
<tr>
<td>sightseeing</td>
<td><code>n</code> 旅游，观光</td>
</tr>
<tr>
<td>aspire</td>
<td><code>vi</code> 立志于，渴望于</td>
</tr>
<tr>
<td>economical</td>
<td><code>adj</code> 经济的，节约的</td>
</tr>
<tr>
<td>harsh</td>
<td><code>adj</code> 刺耳的</td>
</tr>
<tr>
<td>recovery</td>
<td><code>n</code> 痊愈，复苏，恢复</td>
</tr>
<tr>
<td>stationary</td>
<td><code>adj</code> 静止的</td>
</tr>
<tr>
<td>adopt</td>
<td><code>v</code> 收养</td>
</tr>
<tr>
<td>statue</td>
<td><code>n</code> 雕像</td>
</tr>
<tr>
<td>bundle</td>
<td><code>n</code> 一捆，一把</td>
</tr>
<tr>
<td>prime</td>
<td><code>adj</code>主要的 <code>n</code> 青春</td>
</tr>
<tr>
<td>majesty</td>
<td><code>n</code> 王权，雄伟，壮丽</td>
</tr>
<tr>
<td>accurate</td>
<td><code>adj</code> 精确的</td>
</tr>
<tr>
<td>integral</td>
<td><code>adj</code>必需的，基本的</td>
</tr>
<tr>
<td>conduct</td>
<td><code>v</code>指挥，引导<code>n</code>行为举止</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<hr>
<blockquote>
<p> 2021/10/13</p>
</blockquote>
<hr>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>complicated</td>
<td><code>adj</code> 难解的，复杂的</td>
</tr>
<tr>
<td>enrich</td>
<td><code>v</code> 使丰富，使富裕</td>
</tr>
<tr>
<td>intellectual</td>
<td><code>adj </code> 聪明的  <code>n</code> 知识分子</td>
</tr>
<tr>
<td>acknowledge</td>
<td><code>v</code> 告知收到，承认，致谢，致意</td>
</tr>
<tr>
<td>spacious</td>
<td><code>adj</code> 宽敞的，广阔的</td>
</tr>
<tr>
<td>injury</td>
<td><code>vt</code> 使受伤</td>
</tr>
<tr>
<td>cardinal</td>
<td><code>adj</code>  主要的，基本的  <code>n</code> 基数，红衣主教</td>
</tr>
<tr>
<td>worthwhile</td>
<td><code>adj </code>值得的 有意义的</td>
</tr>
<tr>
<td>invalid</td>
<td><code>adj</code>  无效的  <code>n</code> 病人 残疾人</td>
</tr>
<tr>
<td>condemn</td>
<td><code>v</code> 谴责 责备</td>
</tr>
<tr>
<td>surge</td>
<td><code>vi</code>  汹涌，激增  <code>n </code> 波涛汹涌</td>
</tr>
<tr>
<td>dubious</td>
<td><code>adj</code> 可疑的，怀疑的</td>
</tr>
<tr>
<td>shed</td>
<td><code>v</code> 流出（眼泪），蜕皮 ， 使清晰 <code>n</code> 棚屋</td>
</tr>
<tr>
<td>sustain</td>
<td><code>v</code> 支撑，承受</td>
</tr>
<tr>
<td>visible</td>
<td><code>adj</code> 可见的</td>
</tr>
</tbody></table>
<hr>
<blockquote>
<p>2021/10/19</p>
</blockquote>
<hr>
<blockquote>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>comprehensive</td>
<td><code>adj</code> 全面的，详细的，完整的</td>
</tr>
<tr>
<td>conform</td>
<td><code>vi</code> 遵照，顺从  <code>vt</code> 使一致   <code>adj</code> 一致的</td>
</tr>
<tr>
<td>distinction</td>
<td><code>n</code> 优秀，杰出，差别，区分</td>
</tr>
<tr>
<td>feedback</td>
<td><code>n</code> 反馈</td>
</tr>
<tr>
<td>adequate</td>
<td><code>adj</code> 足够的，过得去的</td>
</tr>
<tr>
<td>grasp</td>
<td><code>vt</code>  抓住，抓紧 。领会，理解   <code>n</code> 紧握</td>
</tr>
<tr>
<td>caution</td>
<td><code>n</code> 警告  <code>v</code> 劝…小心谨慎</td>
</tr>
<tr>
<td>vicious</td>
<td><code>adj</code> 凶猛的，残忍的</td>
</tr>
<tr>
<td>product</td>
<td><code>n</code> 产品</td>
</tr>
<tr>
<td>extend</td>
<td><code>v</code> 延伸，涉及，扩展</td>
</tr>
<tr>
<td>influence</td>
<td><code>vt</code> 影响 <code>n</code> 影响</td>
</tr>
<tr>
<td>mobilize</td>
<td><code>v</code> 动员，鼓动</td>
</tr>
<tr>
<td>context</td>
<td><code>n</code> 上下文</td>
</tr>
<tr>
<td>outcome</td>
<td><code>n</code> 后果，结果</td>
</tr>
<tr>
<td>moral</td>
<td><code>n</code> 道德 <code>adj</code> 道德上的</td>
</tr>
<tr>
<td>ensure</td>
<td><code>v</code> 确保</td>
</tr>
<tr>
<td>contribute</td>
<td><code>vt</code> 贡献</td>
</tr>
<tr>
<td>abuse</td>
<td><code>v</code> 虐待，辱骂<code>n</code> 滥用，虐待，辱骂</td>
</tr>
<tr>
<td>grease</td>
<td><code>n</code> 油脂，动物脂<code>v</code> 给…抹油</td>
</tr>
<tr>
<td>humiliate</td>
<td><code>vt</code> 羞辱</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>English</category>
      </categories>
  </entry>
  <entry>
    <title>JAVA设计模式</title>
    <url>/2021/10/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p>
<span id="more"></span>

<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><hr>
<h3 id="2021-10-9-单例模式"><a href="#2021-10-9-单例模式" class="headerlink" title="2021/10/9 单例模式"></a><code>2021/10/9</code> 单例模式</h3><hr>
<h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h4><ul>
<li><p>一个类仅有一个实例</p>
</li>
<li><p>提供一个访问这个实例的方法</p>
</li>
<li><blockquote>
<p>注意只在同一个JVM中才起作用</p>
</blockquote>
</li>
</ul>
<h4 id="2-实现关键"><a href="#2-实现关键" class="headerlink" title="2.实现关键"></a>2.实现关键</h4><ul>
<li>私有构造函数    <code>防止别人直接构造，维持单例</code></li>
<li>私有静态变量维护对象实例    <code>为了保存创建的单例对象，单例不应该销毁</code></li>
<li>公共静态方法提供获取实例    <code>提供获取单例的方法</code></li>
</ul>
<h4 id="3-实现方式"><a href="#3-实现方式" class="headerlink" title="3.实现方式"></a>3.实现方式</h4><ul>
<li><strong>懒汉式</strong>。代码简单易读，延时加载对象实例，但是非线程安全，不能用在多线程环境中。这种代码仅能作为讲解学习代码，严重反对在实际软件中使用。<code>线程不安全，一瞬间的高并发可能产生多个‘单例’</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonLazy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 私有静态变量维护当前对象实例</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonLazy instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 私有构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonLazy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 公有静态方法，获取对象实例</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonLazy <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            instance = <span class="keyword">new</span> SingletonLazy();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>双重检查锁</strong>。这种代码是懒汉式的优化，具备懒汉式的优点，同时增加线程同步锁和双重检查机制，可以在多线程环境中使用。调用效率一般，但是依赖JVM的底层模型，不同JVM版本或者不同厂家的JVM可能会有概率性生成多个实例的情况，不推荐在实际产品中使用。<code>效率低，依赖JVM，有可能失效</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDoubleCheck</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 私有静态变量维护当前对象实例,volatile能保证双重检查锁不被jvm影响失效</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> SingletonDoubleCheck instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 私有构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDoubleCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 公有静态方法，获取对象实例</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDoubleCheck <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonDoubleCheck.class) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//双重检查</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    instance = <span class="keyword">new</span> SingletonDoubleCheck();</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>饿汉式</strong>。 线程安全，调用效率高，但是不能延时加载对象实例，不推荐实际使用。<code>会影响代码执行速度</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonEhan</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有静态变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonEhaninstance = <span class="keyword">new</span> SingletonEhan();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有化构造方法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonEhan</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//公有静态方法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonEhan <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>静态内部类</strong>。这是对饿汉式的优化。线程安全，调用效率高，而且支持延时加载对象实例，推荐使用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInnerStatic</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHoler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态初始化器，由JVM来保证线程安全</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> SingletonInnerStatic instance = </span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> SingletonInnerStatic();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonInnerStatic</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取对象实例的方法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonInnerStatic <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> SingletonHoler.instance;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>单例模式需要确保只生成一个对象实例，我们可以通过下面的三种方式进行攻击，尝试获取多个不同的对象实例。</p>
</blockquote>
<p><strong>三种攻击方式：</strong></p>
<ul>
<li><p><strong>反射攻击</strong>：利用jdk反射API，修改单例类构造函数的访问权限，然后调用构造函数；</p>
</li>
<li><p><strong>序列化攻击</strong>：将单例对象实例以字节流的方式写入到文件中，然后再读取文件字节流，反序列化生成对象实例;</p>
</li>
<li><p>调用对象的克隆方法。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//正常单例对象</span></span><br><span class="line"></span><br><span class="line">    Singleton single1 = Singleton.getInstance();</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 反射攻击</span></span><br><span class="line"></span><br><span class="line">    Class clazz = Singleton.class;</span><br><span class="line"></span><br><span class="line">    Constructor  cons = clazz.getDeclaredConstructor(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    Singleton single2 =(Singleton) cons.newInstance(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 序列化攻击</span></span><br><span class="line"></span><br><span class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line"></span><br><span class="line">     oos.writeObject(single1);</span><br><span class="line"></span><br><span class="line">     oos.flush();</span><br><span class="line"></span><br><span class="line">     oos.close();</span><br><span class="line"></span><br><span class="line">           </span><br><span class="line"></span><br><span class="line">      FileInputStreamfis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">      ObjectInputStreamois = <span class="keyword">new</span> ObjectInputStream(fis);</span><br><span class="line"></span><br><span class="line">      Singleton single3 =(Singleton) ois.readObject();</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">      <span class="comment">//3. clone攻击</span></span><br><span class="line"></span><br><span class="line">      Singleton single4 =(Singleton) single1.clone();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>可以采用如下方式修复漏洞：</strong></p>
</blockquote>
<ul>
<li><p><strong>修复反射漏洞</strong>：反射漏洞的原理是多次调用构造函数。可以在构造函数中增加判断，如果已经生成了实例对象，说明此构造函数已经调用过至少一次，禁止在调用构造函数，此时，判定为非法调用，直接抛出异常。</p>
</li>
<li><p><strong>修复反序列化漏洞：</strong>重写<strong>readResolve()方法</strong>，直接返回实例对象。JVM在处理反序列化生成对象时会回调此方法，直接得到对象实例。</p>
</li>
<li><p><strong>修复克隆漏洞：</strong>重写**clone()**方法，直接返回实例对象。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> longserialVersionUID =-<span class="number">2516616785479458264L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 防止反射漏洞</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (instance != <span class="keyword">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取对象实例</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化时，如果定义了readResolve()，则直接返回此方法指定的对象，而不需要单独在创建新对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止Clone生成新的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>单元素枚举类</strong>。这是一种稍微少见的代码写法，线程安全，调用效率高，并且由于JVM对枚举类的特殊处理方式，天然的解决了前面的安全漏洞。但是，如果希望在首次初始化对象时运行全局逻辑，这种方式会比较困难。需要根据实际功能场景考虑使用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">SingletonEnum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个枚举的元素，它 就代表了Singleton的一个实例</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">singletonOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 功能处理</span></span><br><span class="line"></span><br><span class="line">        System.err.println(<span class="string">&quot;功能处理&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//客户端调用示例</span></span><br><span class="line"></span><br><span class="line">        SingletonEnum.INSTANCE.singletonOperation();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2021-20-19简单工厂模式以及UML类图"><a href="#2021-20-19简单工厂模式以及UML类图" class="headerlink" title="2021/20/19简单工厂模式以及UML类图"></a><code>2021/20/19</code>简单工厂模式以及UML类图</h3><hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">今天发现一本适合设计模式初学者的书，以后设计模式跟着《大话设计模式》这本书学习</span><br></pre></td></tr></table></figure>

<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><img src="https://nanamyblog.oss-cn-beijing.aliyuncs.com/javaStream/2.png" alt="示例"></p>
<h4 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h4><p><img src="https://nanamyblog.oss-cn-beijing.aliyuncs.com/javaStream/1.png" alt="uml"></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
  </entry>
  <entry>
    <title>flutter</title>
    <url>/2021/10/12/flutter/</url>
    <content><![CDATA[<p>flutter学习。Flutter是Google开源的构建用户界面（UI）工具包，帮助开发者通过一套代码库高效构建多平台精美应用，支持移动、Web、桌面和嵌入式平台。</p>
<span id="more"></span>

<h3 id="1-搭建Flutter运行环境"><a href="#1-搭建Flutter运行环境" class="headerlink" title="1.搭建Flutter运行环境"></a>1.搭建Flutter运行环境</h3><p>一、 电脑上面安装配置 JDK</p>
<p>二、 电脑上下载安装 Android Studio</p>
<p>三、电脑上面下载配置 Flutter SDK</p>
<p>四、电脑上配置 Flutter 国内镜像</p>
<p>搭建环境过程中要下载很多资源文件，当一些资源下载不了的时候，可能会报各种错误。在<br>国内访问 Flutter 的时候有可能会受到限制。Flutter 官方为我们提供了国内的镜像<br><a href="https://flutter-io.cn/">https://flutter-io.cn/</a><br><a href="https://flutter.dev/community/china">https://flutter.dev/community/china</a><br>拉到 Flutter 中文网最下面有配置方式，把下面两句配置到环境变量里面（单独新建环境变量）<br>FLUTTER_STORAGE_BASE_URL: <a href="https://storage.flutter-io.cn/">https://storage.flutter-io.cn</a><br>PUB_HOSTED_URL: <a href="https://pub.flutter-io.cn/">https://pub.flutter-io.cn</a></p>
<p>五、运行 flutter doctor 命令检测环境是否配置成功，按提示修改</p>
<p>六、打开 Android Studio 安装 Flutter 插件</p>
<p>七、创建 Flutter 项目</p>
<p>八、Android Studio 中导入运行 Flutter 项目 运行项目</p>
<h3 id="2-Flutter真机调试"><a href="#2-Flutter真机调试" class="headerlink" title="2.Flutter真机调试"></a>2.Flutter真机调试</h3><p>1、准备一台 Android 手机<br>2、手机需要开启调试模式<br>3、用数据线把手机连上电脑<br>4、手机要允许电脑进行 Usb 调试<br>5、手机对应的 sdk 版本必须安装</p>
<h3 id="3-Vscode-中开发运行-Flutter-应用"><a href="#3-Vscode-中开发运行-Flutter-应用" class="headerlink" title="3.Vscode 中开发运行 Flutter 应用"></a>3.Vscode 中开发运行 Flutter 应用</h3><h4 id="一常用命令"><a href="#一常用命令" class="headerlink" title="一常用命令"></a>一常用命令</h4><p>1、Vscode 中安装 Flutter 插件 Dart插件</p>
<p>2、Vscode 中打开 flutter 项目进行开发<br>3、运行 Flutter 项目<code>flutter run</code><br>r 键：点击后热加载，也就算是重新加载吧。<br>R键，重新编译运行。<br>p 键：显示网格，这个可以很好的掌握布局情况，工作中很有用。<br>o 键：切换 android 和 ios 的预览模式。<br>q 键：退出调试预览模式</p>
<p>4、</p>
<p><code>fim</code>     <code>import &#39;package:flutter/material.dart&#39;;</code></p>
<p><code>stss</code>     <code>class  extends StatelessWidget</code></p>
<h4 id="二目录结构"><a href="#二目录结构" class="headerlink" title="二目录结构"></a>二目录结构</h4><table>
<thead>
<tr>
<th>文件夹</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>android</td>
<td>android 平台相关代码</td>
</tr>
<tr>
<td>ios</td>
<td>ios 平台相关代码</td>
</tr>
<tr>
<td>lib</td>
<td>flutter 相关代码，我们主要编写的代码就在这个文件夹</td>
</tr>
<tr>
<td>test</td>
<td>用于存放测试代码</td>
</tr>
<tr>
<td>pubspec.yaml</td>
<td>配置文件，一般存放一些第三方库的依赖。</td>
</tr>
</tbody></table>
<h4 id="三入口文件"><a href="#三入口文件" class="headerlink" title="三入口文件"></a>三入口文件</h4><p>lib文件的<code>main.dart</code> 是整个项目的入口文件</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main()&#123;</span><br><span class="line">runApp(MyApp());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//也可以简写</span></span><br><span class="line"><span class="keyword">void</span> main()=&gt;runApp(MyApp());</span><br></pre></td></tr></table></figure>

<ul>
<li>MyApp是自定义的一个组件。<code>widget</code></li>
<li>在 Flutter 中组件其实就是一个类。</li>
<li>组件这个类需要继承  StatelessWidget/StatefulWidget。</li>
<li>StatelessWidget 是无状态组件，状态不可变的 widget。</li>
<li>StatefulWidget 是有状态组件，持有的状态可能在 widget 生命周期改变。</li>
</ul>
<h4 id="四-MaterialApp和Scoffold组件"><a href="#四-MaterialApp和Scoffold组件" class="headerlink" title="四 MaterialApp和Scoffold组件"></a>四 MaterialApp和Scoffold组件</h4><ul>
<li>MaterialApp</li>
</ul>
<p>MaterialApp 是一个方便的 Widget，它封装了应用程序实现 Material Design 所需要的<br>一些 Widget。一般作为顶层 widget 使用。</p>
<p>常用的属性：<br>home（主页）<br>title（标题）<br>color（颜色）<br>theme（主题）<br>routes（路由）<br>…</p>
<p><code>我理解的MaterialApp 其实定义了整体的主题以及框架</code></p>
<ul>
<li>Scaffold</li>
</ul>
<p>Scaffold 是 Material Design 布局结构的基本实现。此类提供了用于显示 drawer、snackbar 和底部 sheet 的 API。<br>Scaffold 有下面几个主要属性：<br>appBar - 显示在界面顶部的一个 AppBar。<br>body - 当前界面所显示的主要内容 Widget。<br>drawer - 抽屉菜单控件。<br>…</p>
<p><code>Scoffold其实是一个页面框架，定义了一个页面的结构</code></p>
<h4 id="五问：Flutter构造方法为什么要使用const关键字？"><a href="#五问：Flutter构造方法为什么要使用const关键字？" class="headerlink" title="五问：Flutter构造方法为什么要使用const关键字？"></a>五问：Flutter构造方法为什么要使用const关键字？</h4><p>答：const关键字是用来返回const对象给声明为const的参数赋值用的。<br>如果没有const关键字，则给声明为const的参数赋值时，会报错<br>Error: Cannot invoke a non-‘const’ constructor where a const expression is expected.<br>但是const构造方法并不总是返回const对象，当给声明为const或final的参数赋值时，<br>会返回一个const对象，如果是给可变参数赋值，则返回一个可变的对象。</p>
<h4 id="六Container、Text组件"><a href="#六Container、Text组件" class="headerlink" title="六Container、Text组件"></a>六Container、Text组件</h4><ul>
<li>Container布局使用，相当于div</li>
<li>Text文本</li>
</ul>
<h4 id="七Image图片组件"><a href="#七Image图片组件" class="headerlink" title="七Image图片组件"></a>七Image图片组件</h4><ul>
<li>Image 引入远程本地图片</li>
</ul>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title>JAVA stream流</title>
    <url>/2021/10/19/java%E6%B5%81%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<blockquote>
<p>2021/10/19</p>
</blockquote>
<h3 id="java-stream流"><a href="#java-stream流" class="headerlink" title="java stream流"></a>java stream流</h3><p>问题：计算一个列表中的奇数平方和</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="keyword">int</span> sum = numbers.stream()</span><br><span class="line">                .filter(n -&gt; n % <span class="number">2</span>  == <span class="number">1</span>)</span><br><span class="line">                .map(n  -&gt; n * n)</span><br><span class="line">                .reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line"></span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单分析源码</p>
<ul>
<li>stream()方法存在Collection接口中，将Collection实现类转换为Stream类</li>
<li>filter()方法在Stream接口中定义，接受一个叫Predicate的函数式接口实现类。官方解释：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`filter()`: Returns a stream consisting of the elements of this stream that match the given predicate.This is an intermediate operation.</span><br><span class="line"></span><br><span class="line">`Predicate`: Represents a predicate (boolean-valued function) of one argument.</span><br></pre></td></tr></table></figure>

<ul>
<li>map()方法在Stream接口中定义，接受一个叫Function的函数式接口实现类。官方解释：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`map()`: Returns a stream consisting of the results of applying the given function to the elements of this stream.This is an intermediate operation.</span><br><span class="line"></span><br><span class="line">`Function`: Represents a function that accepts one argument and produces a result.</span><br></pre></td></tr></table></figure>

<ul>
<li><p>reduce()方法在Stream接口中定义，接受一个和流相同的泛型类型参数identity和一个BinaryOperator的函数式接口实现类</p>
<p><code>Integer::sum</code>这种写法其实是代表函数的引用，等同于<code>(n1, n2) -&gt; n1 + n2</code> 。<code>Integer.sum</code>代表函数的调用。</p>
<p><code>reduce()</code>对使用BinaryOperator对identity和流里面每个元素进行操作，并将返回值给identity</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`reduce()`: Performs a reduction on the elements of this stream, using the provided identity value and an associative accumulation function, and returns the reduced value. This is a terminal operation.</span><br><span class="line"></span><br><span class="line">`BinaryOperator`: Represents an operation upon two operands of the same type, producing a result of the same type as the operands. This is a specialization of BiFunction for the case where the operands and the result are all of the same type.</span><br><span class="line"></span><br><span class="line">`BiFunction`: Represents a function that accepts two arguments and produces a result. This is the two-arity specialization of Function.</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="流操作与循环操作的区别"><a href="#流操作与循环操作的区别" class="headerlink" title="流操作与循环操作的区别"></a>流操作与循环操作的区别</h4><ul>
<li><code>循环</code>操作是顺序代码，只能由一个线程执行。<code>流</code>被设计为并行处理元素。</li>
<li><code>循环</code>是命令式编程，我们不仅控制要做什么，还要如何做。<code>流</code> 是声明式编程，我们只需要告诉该做什么，该部分如何做由系统本身处理。</li>
</ul>
<h4 id="流的两种操作类型"><a href="#流的两种操作类型" class="headerlink" title="流的两种操作类型"></a>流的两种操作类型</h4><ul>
<li>中间操作</li>
<li>终端操作</li>
</ul>
<p>中间操作不处理元素，直到在流上调用终端操作。</p>
<p>流上的中间操作产生另一流。</p>
<p>Stream通过链式操作以创建流管道。</p>
<p>在上面的代码中filter()和map()都是中间操作。 而reduce()是终端操作。</p>
<h3 id="java流API"><a href="#java流API" class="headerlink" title="java流API"></a>java流API</h3><p>流相关的接口和类在java.util.stream包中。</p>
<p><code>AutoCloseable</code>接口来自java.lang包。</p>
<p>所有流接口从继承自<code>AutoCloseable</code>接口的<code>BaseStream</code>接口继承。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AutoCloseable</span><br><span class="line"> |</span><br><span class="line"> +--BaseStream</span><br><span class="line">     |</span><br><span class="line">     +--IntStream</span><br><span class="line">     |</span><br><span class="line">     +--LongStream</span><br><span class="line">     |</span><br><span class="line">     +--DoubleStream</span><br><span class="line">     |</span><br><span class="line">     +--Stream&lt;T&gt;</span><br></pre></td></tr></table></figure>

<p>如果流使用集合作为其数据源，并且集合不需要关闭。</p>
<p>如果流基于可关闭的数据源（例如文件I/O通道），那么我们可以使用try-with-resources语句创建流，以使其自动关闭。</p>
<h4 id="BaseStream"><a href="#BaseStream" class="headerlink" title="BaseStream"></a>BaseStream</h4><p>BaseStream接口定义所有类型的流的所有方法。</p>
<ul>
<li><code>Iterator&lt;T&gt; iterator()</code><br>终端操作<br>返回流的迭代器。</li>
<li><code>sequential()</code><br>中间操作<br>返回顺序流。 如果流已经是顺序的，则它返回自身。 它将并行流转换为顺序流。</li>
<li><code>parallel()</code><br>中间操作<br>返回并行流。 如果流已经是并行的，则它返回自身。 它将并行流转换为顺序流。</li>
<li><code>boolean isParallel()</code><br>如果流是并行，则返回true，否则返回false。<br>在调用终端流操作方法后调用此方法可能会产生不可预测的结果。</li>
<li><code>unordered()</code><br>中间操作<br>返回流的无序版本。 如果流已经是无序的，则它返回自身。</li>
</ul>
<h4 id="流"><a href="#流" class="headerlink" title="流"></a>流</h4><p><code>Stream&lt;T&gt; </code>接口表示元素类型T的流。</p>
<p><code>Stream &lt;T&gt;</code>接口包含诸如filter()，map()，reduce()，collect()，max()，min()等。</p>
<p>当使用原始类型时，我们可以使用三个专门的流接口，称为<code>IntStream</code>，<code>LongStream</code>和<code>DoubleStream</code>。</p>
<p>这些接口提供了处理原始值的方法。</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
  </entry>
</search>
